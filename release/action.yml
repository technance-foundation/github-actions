name: Release (Changesets + pnpm, auto on main)
description: >
    Fully automated release action that runs on pushes to main.
    Uses Changesets to bump versions, remove .changeset files, commit & push,
    and publish packages with pnpm.

branding:
    icon: package
    color: blue

inputs:
    # Node / pnpm
    node-version:
        description: "Explicit Node.js version"
        default: "20"
        required: false
    pnpm-version:
        description: "pnpm version to install"
        default: "9.0.6"
        required: false
    cache:
        description: "Cache strategy for setup-node (pnpm|npm|yarn|false)"
        default: "pnpm"
        required: false

    # Registry / Auth
    npm-registry:
        description: "NPM registry URL"
        default: "https://registry.npmjs.org"
        required: false
    npm-token:
        description: "NPM token for authentication (optional, required for publishing)"
        required: false

    # Token used for pushing release commits
    push-token:
        description: >
            Token used to push release commits.
            Can be:
            - a user/bot PAT with repo write access, or
            - a GitHub App installation access token.
            If omitted, falls back to GITHUB_TOKEN (may be blocked by branch protection).
        required: false
        default: ""

    # Commands
    install-command:
        description: "Dependency install command"
        default: "pnpm install --frozen-lockfile"
        required: false
    build-command:
        description: "Build command"
        default: "pnpm build"
        required: false
    version-command:
        description: "Changesets version command (bump versions and remove .changeset files)"
        default: "pnpm run bump"
        required: false
    publish-command:
        description: "Publish command (usually pnpm run release or pnpm changeset publish)"
        default: "pnpm run release"
        required: false

    # Misc / Git
    working-directory:
        description: "Working directory to run all commands in"
        required: false
    git-user-name:
        description: "Git user.name for release commit"
        default: "github-actions[bot]"
        required: false
    git-user-email:
        description: "Git user.email for release commit"
        default: "github-actions[bot]@users.noreply.github.com"
        required: false
    commit-style:
        description: "Commit message style: normal|conventional"
        default: "normal"
        required: false
    commit-message:
        description: "Override commit message completely. If set, commit-style and auto generation are ignored."
        default: ""
        required: false

outputs:
    published:
        description: "Whether a publish occurred"
        value: ${{ steps.set-output.outputs.published }}
    new_version:
        description: "Captured example new version from Changesets status (best effort)"
        value: ${{ steps.set-output.outputs.new_version }}

runs:
    using: composite
    steps:
        - name: Checkout
          uses: actions/checkout@v4
          with:
              fetch-depth: 0
              # Use push-token if provided, otherwise fall back to GITHUB_TOKEN
              token: ${{ inputs.push-token != '' && inputs.push-token || github.token }}
              # Only persist credentials when we are *not* using a custom push-token
              persist-credentials: ${{ inputs.push-token == '' }}

        - name: Setup git
          shell: bash
          run: |
              git config --global user.email "${{ inputs.git-user-email }}"
              git config --global user.name "${{ inputs.git-user-name }}"

        - name: Setup pnpm
          uses: pnpm/action-setup@v4
          with:
              version: ${{ inputs.pnpm-version }}
              run_install: false

        - name: Setup Node.js
          uses: actions/setup-node@v4
          with:
              node-version: ${{ inputs.node-version }}
              registry-url: ${{ inputs.npm-registry }}
              cache: ${{ inputs.cache }}
              cache-dependency-path: |
                  **/pnpm-lock.yaml

        - name: Verify required tools
          shell: bash
          run: |
              set -e
              if ! command -v jq >/dev/null 2>&1; then
                echo "jq is required but was not found on PATH."
                echo "If you're using a self-hosted runner, install jq (and ensure bash is available)."
                exit 1
              fi

              if ! command -v gh >/dev/null 2>&1; then
                echo "gh (GitHub CLI) is required but was not found on PATH."
                echo "On GitHub-hosted runners it is preinstalled. On self-hosted, install gh."
                exit 1
              fi

        - name: Authenticate NPM registry (optional)
          if: ${{ inputs.npm-token != '' }}
          shell: bash
          env:
              NPM_TOKEN: ${{ inputs.npm-token }}
          run: |
              echo "//registry.npmjs.org/:_authToken=$NPM_TOKEN" > ~/.npmrc

        - name: Check for pending changesets
          id: changeset-status
          shell: bash
          working-directory: ${{ inputs.working-directory }}
          run: |
              set -euo pipefail

              if [ ! -d ".changeset" ]; then
                echo "has_changesets=false" >> "$GITHUB_OUTPUT"
                echo "No .changeset directory found; skipping release."
                exit 0
              fi

              # Try to get JSON status without installing repo deps.
              if pnpm dlx @changesets/cli status --output=release.json; then
                # Filter out ignored packages (from .changeset/config.json) before deciding whether to release
                IGNORE_LIST="[]"
                if [ -f ".changeset/config.json" ]; then
                  IGNORE_LIST="$(jq -c '.ignore // []' .changeset/config.json 2>/dev/null || echo '[]')"
                fi

                TMP_FILE="$(mktemp)"
                if jq --argjson ignore "$IGNORE_LIST" '
                  .releases = (.releases // [] | map(select(.name as $n | ($ignore | index($n) | not))))
                ' release.json > "$TMP_FILE"; then
                  mv "$TMP_FILE" release.filtered.json
                else
                  rm -f "$TMP_FILE" || true
                  echo '{"releases":[]}' > release.filtered.json
                fi

                RELEASE_COUNT="$(jq -r '.releases | length' release.filtered.json || echo 0)"
                if [ "$RELEASE_COUNT" -eq 0 ]; then
                  echo "No pending (non-ignored) changesets; skipping release."
                  echo "has_changesets=false" >> "$GITHUB_OUTPUT"
                else
                  echo "Found $RELEASE_COUNT pending (non-ignored) releases."
                  echo "has_changesets=true" >> "$GITHUB_OUTPUT"
                  # Best-effort example new version
                  NEW_VERSION="$(jq -r '.releases[0].newVersion // empty' release.filtered.json || echo '')"
                  echo "new_version=$NEW_VERSION" >> "$GITHUB_OUTPUT"
                fi
              else
                echo "changeset status failed; aborting." >&2
                exit 1
              fi

        - name: Install dependencies
          if: ${{ steps.changeset-status.outputs.has_changesets == 'true' }}
          shell: bash
          working-directory: ${{ inputs.working-directory }}
          run: ${{ inputs.install-command }}

        - name: Build packages
          if: ${{ steps.changeset-status.outputs.has_changesets == 'true' }}
          shell: bash
          working-directory: ${{ inputs.working-directory }}
          run: ${{ inputs.build-command }}

        - name: Apply version bumps with Changesets
          if: ${{ steps.changeset-status.outputs.has_changesets == 'true' }}
          shell: bash
          working-directory: ${{ inputs.working-directory }}
          run: |
              set -e
              echo "Running version command: ${{ inputs.version-command }}"
              ${{ inputs.version-command }}

        - name: Check for git changes after versioning
          if: ${{ steps.changeset-status.outputs.has_changesets == 'true' }}
          id: git-diff
          shell: bash
          working-directory: ${{ inputs.working-directory }}
          run: |
              set -e
              if [ -z "$(git status --porcelain)" ]; then
                echo "No git changes after versioning; skipping commit & publish."
                echo "has_changes=false" >> "$GITHUB_OUTPUT"
              else
                echo "Detected git changes after versioning."
                git status --short
                echo "has_changes=true" >> "$GITHUB_OUTPUT"
              fi

        - name: Generate dynamic commit message
          if: ${{ steps.changeset-status.outputs.has_changesets == 'true' && steps.git-diff.outputs.has_changes == 'true' }}
          id: commit-message
          shell: bash
          working-directory: ${{ inputs.working-directory }}
          env:
              COMMIT_STYLE: ${{ inputs.commit-style }}
          run: |
              set -e

              STYLE="${COMMIT_STYLE:-normal}"

              RELEASE_FILE="release.filtered.json"
              if [ ! -f "$RELEASE_FILE" ]; then
                echo "release.filtered.json not found; falling back to generic commit message."
                RELEASE_COUNT=0
              else
                RELEASE_COUNT="$(jq -r '.releases | length' "$RELEASE_FILE" || echo 0)"
              fi

              if [ "$RELEASE_COUNT" -eq 0 ]; then
                if [ "$STYLE" = "conventional" ]; then
                  MESSAGE="chore: release package(s)"
                else
                  MESSAGE="Release package(s)"
                fi

              elif [ "$RELEASE_COUNT" -eq 1 ]; then
                NAME="$(jq -r '.releases[0].name' "$RELEASE_FILE")"
                VERSION="$(jq -r '.releases[0].newVersion' "$RELEASE_FILE")"

                if [ "$STYLE" = "conventional" ]; then
                  MESSAGE="chore: release ${NAME}@${VERSION}"
                else
                  MESSAGE="Release \`${NAME}@${VERSION}\`"
                fi

              else
                if [ "$STYLE" = "conventional" ]; then
                  MESSAGE="chore: release packages\n\n"
                else
                  MESSAGE="Release packages\n\n"
                fi

                while IFS= read -r ROW; do
                  NAME=$(echo "$ROW" | jq -r '.name')
                  VERSION=$(echo "$ROW" | jq -r '.newVersion')
                  MESSAGE="${MESSAGE}- Released \`${NAME}@${VERSION}\`\n"
                done < <(jq -c '.releases[]' "$RELEASE_FILE")
              fi

              {
                echo "message<<EOF"
                printf '%b' "$MESSAGE"
                echo
                echo "EOF"
              } >> "$GITHUB_OUTPUT"

        - name: Commit & push version bump
          if: ${{ steps.changeset-status.outputs.has_changesets == 'true' && steps.git-diff.outputs.has_changes == 'true' }}
          shell: bash
          working-directory: ${{ inputs.working-directory }}
          env:
              GITHUB_REF_NAME: ${{ github.ref_name }}
              PUSH_TOKEN: ${{ inputs.push-token }}
              COMMIT_MESSAGE: ${{ inputs.commit-message != '' && inputs.commit-message || steps.commit-message.outputs.message }}
          run: |
              set -euo pipefail

              echo "Committing with message:"
              echo "$COMMIT_MESSAGE"

              # Stage everything, then explicitly ensure release artifacts are NOT committed
              git add -A
              git reset -- release.json release.filtered.json 2>/dev/null || true

              # If no changes remain staged, skip
              if git diff --cached --quiet; then
                echo "No staged changes after excluding release artifacts; skipping commit."
                exit 0
              fi

              git commit -m "$COMMIT_MESSAGE"

              CURRENT_BRANCH="${GITHUB_REF_NAME:-main}"

              # Only unset the extraheader when we're going to use a PAT/App token
              if [ -n "$PUSH_TOKEN" ]; then
                git config --local --unset-all http.https://github.com/.extraheader || true
                echo "Configuring authenticated remote with provided push-token"
                git remote set-url origin "https://x-access-token:${PUSH_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"
              else
                echo "No push-token provided; using checkout credentials (GITHUB_TOKEN)."
              fi

              echo "Rebasing on latest origin/${CURRENT_BRANCH} before push"
              git fetch origin "${CURRENT_BRANCH}"
              git rebase "origin/${CURRENT_BRANCH}"

              echo "Pushing to origin ${CURRENT_BRANCH}"
              set +e
              git push origin "HEAD:${CURRENT_BRANCH}"
              PUSH_EXIT=$?
              set -e

              if [ "$PUSH_EXIT" -ne 0 ]; then
                echo "Initial push failed (exit code $PUSH_EXIT), attempting force push with lease..."
                git push --force-with-lease origin "HEAD:${CURRENT_BRANCH}"
              else
                echo "Push succeeded."
              fi

        - name: Publish packages
          if: ${{ steps.changeset-status.outputs.has_changesets == 'true' && steps.git-diff.outputs.has_changes == 'true' }}
          shell: bash
          working-directory: ${{ inputs.working-directory }}
          env:
              NODE_AUTH_TOKEN: ${{ inputs.npm-token }}
          run: |
              set -e
              echo "Running publish command: ${{ inputs.publish-command }}"
              ${{ inputs.publish-command }}

        - name: Create git tags for released packages
          if: ${{ steps.changeset-status.outputs.has_changesets == 'true' && steps.git-diff.outputs.has_changes == 'true' }}
          shell: bash
          working-directory: ${{ inputs.working-directory }}
          env:
              PUSH_TOKEN: ${{ inputs.push-token }}
          run: |
              set -euo pipefail

              if [ ! -f release.filtered.json ]; then
                echo "release.filtered.json not found; cannot tag."
                exit 1
              fi

              TAGS="$(jq -r '.releases[] | "\(.name)@\(.newVersion)"' release.filtered.json)"
              echo "Tags to create:"
              echo "$TAGS"

              # Ensure auth is correct for tag push as well
              if [ -n "$PUSH_TOKEN" ]; then
                git config --local --unset-all http.https://github.com/.extraheader || true
                git remote set-url origin "https://x-access-token:${PUSH_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"
              fi

              while IFS= read -r tag; do
                [ -z "$tag" ] && continue
                git tag "$tag" || echo "Tag already exists: $tag"
              done <<< "$TAGS"

              git push origin --tags

        - name: Create GitHub releases for tags
          if: ${{ steps.changeset-status.outputs.has_changesets == 'true' && steps.git-diff.outputs.has_changes == 'true' }}
          shell: bash
          working-directory: ${{ inputs.working-directory }}
          env:
              GH_TOKEN: ${{ inputs.push-token != '' && inputs.push-token || github.token }}
          run: |
              set -euo pipefail

              TAGS="$(jq -r '.releases[] | "\(.name)@\(.newVersion)"' release.filtered.json)"

              while IFS= read -r tag; do
                [ -z "$tag" ] && continue
                echo "Creating GitHub release: $tag"
                gh release create "$tag" \
                  --title "$tag" \
                  --generate-notes \
                  || echo "Release already exists (or cannot create): $tag"
              done <<< "$TAGS"

        - name: Set outputs
          id: set-output
          shell: bash
          run: |
              PUBLISHED="false"
              NEW_VERSION="${{ steps.changeset-status.outputs.new_version }}"

              if [ "${{ steps.changeset-status.outputs.has_changesets }}" = "true" ] && \
                 [ "${{ steps.git-diff.outputs.has_changes }}" = "true" ]; then
                PUBLISHED="true"
              fi

              echo "published=$PUBLISHED" >> "$GITHUB_OUTPUT"
              echo "new_version=$NEW_VERSION" >> "$GITHUB_OUTPUT"

        - name: Cleanup release files
          if: ${{ always() }}
          shell: bash
          working-directory: ${{ inputs.working-directory }}
          run: |
              rm -f release.json release.filtered.json || true
